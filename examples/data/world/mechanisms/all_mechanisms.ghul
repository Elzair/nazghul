//
// Copyright-Only Dedication (based on United States law)
//
// The person or persons who have associated their work with this document (the
// "Dedicator") hereby dedicate the entire copyright in the work of authorship
// identified below (the "Work") to the public domain.
//
// Dedicator makes this dedication for the benefit of the public at large and
// to the detriment of Dedicator's heirs and successors. Dedicator intends this
// dedication to be an overt act of relinquishment in perpetuity of all present
// and future rights under copyright law, whether vested or contingent, in the
// Work. Dedicator understands that such relinquishment of all rights includes
// the relinquishment of all rights to enforce (by lawsuit or otherwise) those
// copyrights in the Work.
//
// Dedicator recognizes that, once placed in the public domain, the Work may be
// freely reproduced, distributed, transmitted, used, modified, built upon, or
// otherwise exploited by anyone for any purpose, commercial or non-commercial,
// and in any way, including by methods that have not yet been invented or
// conceived.
//
/* all_mechanisms.ghul
 *
 * Defines all mechanism types in the world, from various files:
 */
#ifndef all_mechanisms_ghul
#define all_mechanisms_ghul


// These are game-defined signals:
#define MECH_SIGNAL_UP     100
#define MECH_SIGNAL_DOWN   101
#define MECH_SIGNAL_CHANGE 102


// Define a new type of mechanism: a simple lever that could be used to send a
// signal to, say, open a door.
MECH_TYPE mech_L_lever {
  name "lever";
  defaults {
    pmask PASS_ALL;
  }
  states {
    {
      name   "lever up";
      sprite s_L_lever_up;
    }
    {
      name   "lever down";
      sprite s_L_lever_down;
    }
  }
  transitions {
    
    state      "lever up";
    event      MECH_HANDLE;
    next_state "lever down";
    actions {
      send_signal MECH_SIGNAL_DOWN;
    }
    
    state      "lever down";
    event      MECH_HANDLE;
    next_state "lever up";
    actions {
      send_signal MECH_SIGNAL_UP;
    }
  }
} // MECH_TYPE mech_L_lever


MECH_TYPE mech_R_lever {
  name "lever";
  defaults {
    pmask PASS_ALL;
  }
  states {
    {
      name   "lever up";
      sprite s_R_lever_up;
    }
    {
      name   "lever down";
      sprite s_R_lever_down;
    }
  }
  transitions {
    
    state      "lever up";
    event      MECH_HANDLE;
    next_state "lever down";
    actions {
      send_signal MECH_SIGNAL_DOWN;
    }
    
    state      "lever down";
    event      MECH_HANDLE;
    next_state "lever up";
    actions {
      send_signal MECH_SIGNAL_UP;
    }
  }
} // MECH_TYPE mech_L_lever

#define MAKE_SIMPLE_STEP_TRIGGER(type_name, desc, _sprite, _sig) \
MECH_TYPE type_name { \
  name desc; \
  defaults { \
    sprite _sprite; \
    pmask  PASS_ALL; \
  } \
  states { \
    { \
       name   desc; \
    } \
  } \
  transitions { \
    state      desc; \
    event      MECH_STEP; \
    next_state desc; \
    actions { \
      send_signal _sig; \
    } \
  } \
}

MAKE_SIMPLE_STEP_TRIGGER(mech_pressure_plate, "pressure plate", s_floor_plate, MECH_SIGNAL_CHANGE);
MAKE_SIMPLE_STEP_TRIGGER(invisible_step_trigger, "", null, MECH_SIGNAL_DOWN);

// Define a new type of mechanism: a simple door that responds to a signal and
// sends feedback (usually to the sender, but really whoever is wired to
// receive signals from it... confused yet? ;) ).
MECH_TYPE mech_portcullis {
  name "portcullis";
  defaults {}

  states {
    {
      name   "raised portcullis";
      sprite s_portcullis_up;
      pmask  PASS_ALL;
    }
    {
      name   "lowered portcullis";
      sprite s_portcullis_down;
      pmask  PASS_NONE;
    }
  }

  transitions {
    state      "raised portcullis";
    event      MECH_SIGNAL_DOWN;
    next_state "lowered portcullis";
    actions {
      send_signal MECH_SIGNAL_DOWN;
    }
    
    state      "raised portcullis";
    event      MECH_SIGNAL_CHANGE;
    next_state "lowered portcullis";
    actions {
      send_signal MECH_SIGNAL_DOWN;
    }
    
    state      "lowered portcullis";
    event      MECH_SIGNAL_UP;
    next_state "raised portcullis";
    actions {
      send_signal MECH_SIGNAL_UP;
    }
    
    state      "lowered portcullis";
    event      MECH_SIGNAL_CHANGE;
    next_state "raised portcullis";
    actions {
      send_signal MECH_SIGNAL_UP;
    }
  } // transitions

} // MECH_TYPE mech_portcullis


// Define a new type of mechanism: a simple door that responds to a signal and
// sends feedback (usually to the sender, but really whoever is wired to
// receive signals from it... confused yet? ;) ).
MECH_TYPE mech_light {
  name "light";
  defaults {
    sprite null;
    pmask  PASS_ALL;
  }
  states {
    {
      name "lit light source";
      light 1024;
    }
    {
      name "unlit light source";
      light 0;
    }
  }
  transitions {
    
    state      "lit light source";
    event      MECH_SIGNAL_DOWN;
    next_state "unlit light source";
    actions {
      send_signal MECH_SIGNAL_DOWN;
    }
    
    state      "unlit light source";
    event      MECH_SIGNAL_UP;
    next_state "lit light source";
    actions {
      send_signal MECH_SIGNAL_UP;
    }
  }
} // MECH_TYPE mech_light


MECH_TYPE mech_vdoor {
  name "door";
  defaults {}
  states {
    {
      name   "closed door";
      sprite s_door;
      pmask  PASS_NONE;
      opaque 1;
    }
    {
      name   "open door";
      sprite null;
      pmask  PASS_ALL;
      opaque 0;
    }
    {
      name   "locked door";
      sprite s_door_locked;
      pmask  PASS_NONE;
      opaque 1;
    }
    {
      name   "magically locked door";
      sprite s_door_locked;
      pmask  PASS_NONE;
      opaque 1;
    }
  }
  
  transitions {
    
    state      "closed door";
    event      MECH_OPEN;
    next_state "open door";
    actions {
      send_signal MECH_OPEN;
      
      // After 8 turns the door should close automatically.
      // This next line sets an alarm to send the "close"
      // signal to the door after 8 turns.
      set_alarm 8 MECH_CLOSE;
    }
    
    state      "open door";
    event      MECH_CLOSE;
    next_state "closed door";
    actions {
      send_signal MECH_CLOSE;
    }
    
    state      "closed door";
    event      MECH_LOCK;
    next_state "locked door";
    actions {
      send_signal MECH_LOCK;
    }
    
    state      "locked door";
    event      MECH_UNLOCK;
    next_state "closed door";
    actions {
      send_signal MECH_UNLOCK;
    }
    
    state      "closed door";
    event      MECH_MAGIC_LOCK;
    next_state "magically locked door";
    actions {
      send_signal MECH_MAGIC_LOCK;
    }
    
    state      "magically locked door";
    event      MECH_MAGIC_UNLOCK;
    next_state "closed door";
    actions {
      send_signal MECH_MAGIC_UNLOCK;
    }
  }
} // MECH_TYPE mech_vdoor


MECH_TYPE mech_hdoor {
  name "door";
  defaults {}
  states {
    {
      name   "closed door";
      sprite s_hdoor;
      pmask  PASS_NONE;
      opaque 1;
    }
    {
      name   "open door";
      sprite null;
      pmask  PASS_ALL;
      opaque 0;
    }
    {
      name   "locked door";
      sprite s_hdoor_locked;
      pmask  PASS_NONE;
      opaque 1;
    }
    {
      name   "magically locked door";
      sprite s_hdoor_locked;
      pmask  PASS_NONE;
      opaque 1;
    }
  }
  
  transitions {
    
    state      "closed door";
    event      MECH_OPEN;
    next_state "open door";
    actions {
      send_signal MECH_OPEN;
      
      // After 8 turns the door should close automatically.
      // This next line sets an alarm to send the "close"
      // signal to the door after 8 turns.
      set_alarm 16 MECH_CLOSE;
    }
    
    state      "open door";
    event      MECH_CLOSE;
    next_state "closed door";
    actions {
      send_signal MECH_CLOSE;
    }
    
    state      "closed door";
    event      MECH_LOCK;
    next_state "locked door";
    actions {
      send_signal MECH_LOCK;
    }
    
    state      "locked door";
    event      MECH_UNLOCK;
    next_state "closed door";
    actions {
      send_signal MECH_UNLOCK;
    }
    
    state      "closed door";
    event      MECH_MAGIC_LOCK;
    next_state "magically locked door";
    actions {
      send_signal MECH_MAGIC_LOCK;
    }
    
    state      "magically locked door";
    event      MECH_MAGIC_UNLOCK;
    next_state "closed door";
    actions {
      send_signal MECH_MAGIC_UNLOCK;
    }
  }
} // MECH_TYPE mech_hdoor


//
// Water trap
//

MAP m_WATER_TRAP_OPEN {
  type   ascii;
  width  5;
  height 5;
  STD_TERRAIN_PALETTE;
  terrain {
    _ _ _ _ _
    _ _ _ _ _
    _ _ _ _ _
    _ _ _ _ _
    _ _ _ _ _
  }
} // m_WATER_TRAP_OPEN

MAP m_WATER_TRAP_CLOSED {
  type   ascii;
  width  5;
  height 5;
  STD_TERRAIN_PALETTE;
  terrain {
    e e e e e
    e e e e e
    e e e e e
    e e e e e
    e e e e e
  }
} // m_WATER_TRAP_CLOSED

#define MAKE_BLIT_MECH(_name, plc, x, y, map1, map2, w, h, open_msg, close_msg) \
MECH_TYPE _name { \
  name "lever"; \
  defaults { \
    pmask PASS_ALL; \
  } \
  states { \
    { \
      name "lever up"; \
      sprite s_floor_lever_left; \
    } \
    {  \
      name "lever down"; \
      sprite s_floor_lever_right; \
    } \
  } \
  transitions { \
 \
    state "lever up"; \
    event MECH_HANDLE; \
    next_state "lever down"; \
    actions { \
      print open_msg; \
      blit_map plc x y map1 0 0 w h 0; \
    } \
 \
    state "lever down"; \
    event MECH_HANDLE; \
    next_state "lever up"; \
    actions { \
      print close_msg; \
      blit_map plc x y map2 0 0 w h 0; \
    } \
 \
  } \
}

#define MAKE_WATER_TRAP(mech_name, plc, x, y, w, h) \
    MAKE_BLIT_MECH(mech_name, plc, x, y, m_WATER_TRAP_OPEN, m_WATER_TRAP_CLOSED, w, h, "A trap door opens, revealing a watery pit!", "A trap door closes.")

#define MAKE_DRAWBRIDGE(mech_name, plc, x, y) \
    MAKE_BLIT_MECH(mech_name, plc, x, y, m_WATER_TRAP_OPEN, m_WATER_TRAP_CLOSED, 2, 1, "The drawbridge raises.", "The drawbridge lowers.")

MAKE_WATER_TRAP(mech_water_trap_L_lever, p_prison_chamber, 3, 3, 2, 1);


//MAKE_BLIT_MECH(mech_water_trap_L_lever, p_prison_chamber, 3, 3, m_WATER_TRAP_OPEN, m_WATER_TRAP_CLOSED, 2, 1, "A trap door opens, revealing a watery pit!", "A trap door closes.");


#endif // all_mechanisms_ghul

/* eof */
