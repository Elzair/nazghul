//
// Copyright-Only Dedication (based on United States law)
//
// The person or persons who have associated their work with this document (the
// "Dedicator") hereby dedicate the entire copyright in the work of authorship
// identified below (the "Work") to the public domain.
//
// Dedicator makes this dedication for the benefit of the public at large and
// to the detriment of Dedicator's heirs and successors. Dedicator intends this
// dedication to be an overt act of relinquishment in perpetuity of all present
// and future rights under copyright law, whether vested or contingent, in the
// Work. Dedicator understands that such relinquishment of all rights includes
// the relinquishment of all rights to enforce (by lawsuit or otherwise) those
// copyrights in the Work.
//
// Dedicator recognizes that, once placed in the public domain, the Work may be
// freely reproduced, distributed, transmitted, used, modified, built upon, or
// otherwise exploited by anyone for any purpose, commercial or non-commercial,
// and in any way, including by methods that have not yet been invented or
// conceived.
//
/* all_mechanisms.ghul
 *
 * Defines all mechanism types in the world, from various files:
 */
#ifndef all_mechanisms_ghul
#define all_mechanisms_ghul


// These are game-defined signals:
#define MECH_SIGNAL_UP     100
#define MECH_SIGNAL_DOWN   101
#define MECH_SIGNAL_CHANGE 102


// Define a new type of mechanism: a simple lever that could be used to send a
// signal to, say, open a door.
#define MAKE_LEVER_MECH(type_name, m_name, s1_nm, s1_spr, s2_nm, s2_spr) \
MECH_TYPE type_name { \
  name m_name;        \
  defaults {          \
    pmask PASS_ALL;   \
  }                   \
  states {            \
    {                 \
      name   s1_nm;   \
      sprite s1_spr;  \
    }                 \
    {                 \
      name   s2_nm;   \
      sprite s2_spr;  \
    }                 \
  }                   \
  transitions {             \
    state      s1_nm;       \
    event      MECH_HANDLE; \
    next_state s2_nm;       \
    actions {               \
      send_signal MECH_SIGNAL_DOWN; \
    }                       \
    state      s2_nm;       \
    event      MECH_HANDLE; \
    next_state s1_nm;       \
    actions {               \
      send_signal MECH_SIGNAL_UP; \
    } \
  }   \
}

MAKE_LEVER_MECH(mech_L_lever,  "lever", 
                "up",    s_left_lever_up,    
                "down",  s_left_lever_down);
MAKE_LEVER_MECH(mech_R_lever,  "lever", 
                "up",    s_right_lever_up,   
                "down",  s_right_lever_down);
MAKE_LEVER_MECH(mech_T_lever,  "lever", 
                "left",  s_top_lever_left,   
                "right", s_top_lever_right);
MAKE_LEVER_MECH(mech_B_lever,  "lever", 
                "left",  s_bottom_lever_left,
                "right", s_bottom_lever_right);
MAKE_LEVER_MECH(mech_C_lever,  "lever", 
                "left",  s_floor_lever_left, 
                "right", s_floor_lever_right);


#if 0
MECH_TYPE mech_L_lever {
  name "lever";
  defaults {
    pmask PASS_ALL;
  }
  states {
    {
      name   "up";
      sprite s_L_lever_up;
    }
    {
      name   "down";
      sprite s_L_lever_down;
    }
  }
  transitions {
    
    state      "up";
    event      MECH_HANDLE;
    next_state "down";
    actions {
      send_signal MECH_SIGNAL_DOWN;
    }
    
    state      "down";
    event      MECH_HANDLE;
    next_state "up";
    actions {
      send_signal MECH_SIGNAL_UP;
    }
  }
} // MECH_TYPE mech_L_lever


MECH_TYPE mech_R_lever {
  name "lever";
  defaults {
    pmask PASS_ALL;
  }
  states {
    {
      name   "up";
      sprite s_R_lever_up;
    }
    {
      name   "down";
      sprite s_R_lever_down;
    }
  }
  transitions {
    
    state      "up";
    event      MECH_HANDLE;
    next_state "down";
    actions {
      send_signal MECH_SIGNAL_DOWN;
    }
    
    state      "down";
    event      MECH_HANDLE;
    next_state "up";
    actions {
      send_signal MECH_SIGNAL_UP;
    }
  }
} // MECH_TYPE mech_L_lever
#endif // 0


#define MAKE_SIMPLE_STEP_TRIGGER(type_name, _name, _state, _sprite, _sig, _invisible) \
MECH_TYPE type_name { \
  name _name; \
  defaults { \
    sprite _sprite; \
    pmask  PASS_ALL; \
    invisible _invisible; \
  } \
  states { \
    { \
       name   _state; \
    } \
  } \
  transitions { \
    state      _state; \
    event      MECH_STEP; \
    next_state _state; \
    actions { \
      send_signal _sig; \
    } \
  } \
}

MAKE_SIMPLE_STEP_TRIGGER(mech_pressure_plate,    "pressure plate", "simple",
                         s_floor_plate,          MECH_SIGNAL_CHANGE, 0);
MAKE_SIMPLE_STEP_TRIGGER(invisible_step_trigger, "trigger", "invisible",
                         null,                   MECH_SIGNAL_DOWN, 1);

MECH_TYPE mech_portcullis {
  name "portcullis";
  defaults {}

  states {
    {
      name   "raised";
      sprite s_portcullis_up;
      pmask  PASS_ALL;
    }
    {
      name   "lowered";
      sprite s_portcullis_down;
      pmask  SOLID;
    }
  }

  transitions {
    state      "raised";
    event      MECH_SIGNAL_DOWN;
    next_state "lowered";
    actions {
      send_signal MECH_SIGNAL_DOWN;
    }
    
    state      "raised";
    event      MECH_SIGNAL_CHANGE;
    next_state "lowered";
    actions {
      send_signal MECH_SIGNAL_DOWN;
    }
    
    state      "lowered";
    event      MECH_SIGNAL_UP;
    next_state "raised";
    actions {
      send_signal MECH_SIGNAL_UP;
    }
    
    state      "lowered";
    event      MECH_SIGNAL_CHANGE;
    next_state "raised";
    actions {
      send_signal MECH_SIGNAL_UP;
    }
  } // transitions

} // MECH_TYPE mech_portcullis


MECH_TYPE mech_light {
  name "light source";
  defaults {
    sprite null;
    pmask  PASS_ALL;
  }
  states {
    {
      name "lit";
      light 1024;
    }
    {
      name "unlit";
      light 0;
    }
  }
  transitions {
    
    state      "lit";
    event      MECH_SIGNAL_DOWN;
    next_state "unlit";
    actions {
      send_signal MECH_SIGNAL_DOWN;
    }
    
    state      "unlit";
    event      MECH_SIGNAL_UP;
    next_state "lit";
    actions {
      send_signal MECH_SIGNAL_UP;
    }
  }
} // MECH_TYPE mech_light


MECH_TYPE mech_vdoor {
  name "door";
  defaults {}
  states {
    {
      name   "closed";
      sprite s_door;
      pmask  SOLID;
      opaque 1;
    }
    {
      name   "open door";
      sprite null;
      pmask  PASS_ALL;
      opaque 0;
    }
    {
      name   "locked";
      sprite s_door_locked;
      pmask  SOLID;
      opaque 1;
    }
    {
      name   "magically locked";
      sprite s_door_locked;
      pmask  SOLID;
      opaque 1;
    }
  }
  
  transitions {
    
    state      "closed";
    event      MECH_OPEN;
    next_state "open door";
    actions {
      send_signal MECH_OPEN;
      
      // After 8 turns the door should close automatically.
      // This next line sets an alarm to send the "close"
      // signal to the door after 8 turns.
      set_alarm 8 MECH_CLOSE;
    }
    
    state      "open door";
    event      MECH_CLOSE;
    next_state "closed";
    actions {
      send_signal MECH_CLOSE;
    }
    
    state      "closed";
    event      MECH_LOCK;
    next_state "locked";
    actions {
      send_signal MECH_LOCK;
    }
    
    state      "locked";
    event      MECH_UNLOCK;
    next_state "closed";
    actions {
      send_signal MECH_UNLOCK;
    }
    
    state      "closed";
    event      MECH_MAGIC_LOCK;
    next_state "magically locked";
    actions {
      send_signal MECH_MAGIC_LOCK;
    }
    
    state      "magically locked";
    event      MECH_MAGIC_UNLOCK;
    next_state "closed";
    actions {
      send_signal MECH_MAGIC_UNLOCK;
    }
  }
} // MECH_TYPE mech_vdoor


MECH_TYPE mech_hdoor {
  name "door";
  defaults {}
  states {
    {
      name   "closed";
      sprite s_hdoor;
      pmask  SOLID;
      opaque 1;
    }
    {
      name   "open";
      sprite null;
      pmask  PASS_ALL;
      opaque 0;
    }
    {
      name   "locked";
      sprite s_hdoor_locked;
      pmask  SOLID;
      opaque 1;
    }
    {
      name   "magically locked";
      sprite s_hdoor_locked;
      pmask  SOLID;
      opaque 1;
    }
  }
  
  transitions {
    
    state      "closed";
    event      MECH_OPEN;
    next_state "open";
    actions {
      send_signal MECH_OPEN;
      
      // After 8 turns the door should close automatically.
      // This next line sets an alarm to send the "close"
      // signal to the door after 8 turns.
      set_alarm 16 MECH_CLOSE;
    }
    
    state      "open";
    event      MECH_CLOSE;
    next_state "closed";
    actions {
      send_signal MECH_CLOSE;
    }
    
    state      "closed";
    event      MECH_LOCK;
    next_state "locked";
    actions {
      send_signal MECH_LOCK;
    }
    
    state      "locked";
    event      MECH_UNLOCK;
    next_state "closed";
    actions {
      send_signal MECH_UNLOCK;
    }
    
    state      "closed";
    event      MECH_MAGIC_LOCK;
    next_state "magically locked";
    actions {
      send_signal MECH_MAGIC_LOCK;
    }
    
    state      "magically locked";
    event      MECH_MAGIC_UNLOCK;
    next_state "closed";
    actions {
      send_signal MECH_MAGIC_UNLOCK;
    }
  }
} // MECH_TYPE mech_hdoor


//
// Water trap
//

MAP m_WATER_TRAP_OPEN {
  type   ascii;
  width  5;
  height 5;
  STD_TERRAIN_PALETTE;
  terrain {
    "_ _ _ _ _";
    "_ _ _ _ _";
    "_ _ _ _ _";
    "_ _ _ _ _";
    "_ _ _ _ _";
  }
} // m_WATER_TRAP_OPEN

MAP m_WATER_TRAP_CLOSED {
  type   ascii;
  width  5;
  height 5;
  STD_TERRAIN_PALETTE;
  terrain {
    "e e e e e";
    "e e e e e";
    "e e e e e";
    "e e e e e";
    "e e e e e";
  }
} // m_WATER_TRAP_CLOSED

#define MAKE_BLIT_MECH(_name, plc, x, y, map1, map2, w, h, open_msg, close_msg) \
MECH_TYPE _name { \
  name "lever"; \
  defaults { \
    pmask PASS_ALL; \
  } \
  states { \
    { \
      name "up"; \
      sprite s_floor_lever_left; \
    } \
    {  \
      name "down"; \
      sprite s_floor_lever_right; \
    } \
  } \
  transitions { \
 \
    state "up"; \
    event MECH_HANDLE; \
    next_state "down"; \
    actions { \
      print open_msg; \
      blit_map plc x y map1 0 0 w h 0; \
    } \
 \
    state "down"; \
    event MECH_HANDLE; \
    next_state "up"; \
    actions { \
      print close_msg; \
      blit_map plc x y map2 0 0 w h 0; \
    } \
 \
  } \
}

#define MAKE_WATER_TRAP(mech_name, plc, x, y, w, h) \
    MAKE_BLIT_MECH(mech_name, plc, x, y, \
                   m_WATER_TRAP_OPEN, m_WATER_TRAP_CLOSED, w, h, \
                   "A trap door opens, revealing a watery pit!", \
                   "A trap door closes.")

#define MAKE_DRAWBRIDGE(mech_name, plc, x, y) \
    MAKE_BLIT_MECH(mech_name, plc, x, y, \
                   m_WATER_TRAP_OPEN, m_WATER_TRAP_CLOSED, 2, 1, \
                   "The drawbridge raises.", \
                   "The drawbridge lowers.")

MAKE_WATER_TRAP(mech_water_trap_L_lever, p_prison_chamber, 3, 3, 2, 1);


//MAKE_BLIT_MECH(mech_water_trap_L_lever, p_prison_chamber, 3, 3, m_WATER_TRAP_OPEN, m_WATER_TRAP_CLOSED, 2, 1, "A trap door opens, revealing a watery pit!", "A trap door closes.");


#endif // all_mechanisms_ghul

/* eof */
